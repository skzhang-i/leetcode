# Logs
### 2020.07
| Date | File | Description |
| :---- | :---- | :-----------|
|07-12|SearchInsertPos.h|Algo #35. Used binary search.|
|07-12|TwoSum.h|Algo #1. Tried to use hash map. Submitted brute-force solution.|
|07-12|ValidParentheses.h|Algo #20. An easy one. Using stack.|
|07-12|MaximumSubarray.h|Algo #53. Took me some time to solve it. [Review](https://leetcode.com/problems/maximum-subarray/)|
|07-12|BestTimeStock.h|Algo #121. Similar to #53.|
|07-12|BestTimeStock2.h|Algo #122. Another easy one.|
|07-12|Sqrtx.h|Algo #69. Binary search. Faster than 100%.|
|07-13|LongestCommonPrefix.h|#14 The detail matters. Using iterator to see if we meet an end.|
|07-13|ImplementStrStr.h|#28 Brute force. Stupid but simple. |
|07-13|Powxn.h|#50 Recursive method. Write it correctly!|
|07-13|ReverseInteger.h|#7 Don't use compiler features! [Review](https://leetcode.com/problems/reverse-integer/)|
|07-14|DivideTwoIntegers.h|#29 Used bit operations but slow. Maybe I should see if I can improve it someday. [Review](https://leetcode.com/problems/divide-two-integers/)|
|07-14|PlusOne.h|#66 Easy.|
|07-14|ClimbingStairs.h|#70 It's a Fibonacci sequence problem. Don't use recursive method. It's slow!|
|07-15|CountPrime.h|#204 Slow.|
|07-15|ReverseString.h|#344 Very easy.|
|07-16|FizzBuzz.h|#412 Very easy.|
|07-16|SumofTwoIntegers.h|#371 Bit operations. Again, the leetcode complier is strict.|
|07-16|MoveZeroes.h|#283 The use of iterator.|
|07-16|PowerofThree.h|#326 It's like a code cold joke.|
|07-17|SortColors.h|#75 Put 0 to the left and 2 to the right. Make sure you have already checked every element.|
|07-18|JumpGame.h|#55 I thought for a moment. Pretty easy, after you did it.|
|07-18|UniquePaths.h|#62 Used additional space to store result to avoid calculating again.|
|07-18|Numberof1Bits.h|#191 Bit operations. There's a wicked method, by using bitset.count().|
|07-18|ReverseBits.h|#190 Used bitset.|
|07-18|ContainsDuplicate.h|#217 I tried a lot of methods, finding it's hard to improve the time cost(56ms). [Review](https://leetcode.com/problems/contains-duplicate/)|
|07-19|FirstUniqueCharacter.h|#387 At first glance I want to use unordered_map. Then I found that I only need a random-accedd structure.|
|07-19|MajorityElement.h|#169 Used unordered_map. Tried to optimize the bucket size but failed. Even if i succeed it wouldn't imporve a lot.|
|07-20|ValidAnagram.h|#242 Very easy.|
|07-20|MissingNumber.h|#268 Very easy. Calculate the sum of numbers bewteen 0 and n, then subtract the numbers in the vector.|
|07-20|IntersectionofTwoArrays2.h|#350 A little bit slow.|
|07-26|RomantoInteger.h|#13 Easy with recursive method.|
|07-26|RemoveDuplicatesfromSortedArray.h|#26 Easy.|
|07-26|CountandSay.h|#38 Easy. Though I can't understand the description for a while.|
|07-26|MergeSortedArray.h|#88 Easy problem, hard coding. It made my thought fall into chaos several times. [Review](https://leetcode.com/problems/merge-sorted-array/)|
|07-27|PascalTriangle.h|#118 Easy.|
|07-27|SingleNumber.h|#136 It can be done by bit operations.|
|07-27|ValidPalindrome.h|#125 Beware of out of bound errors.|
|07-29|ExcelSheetColumnNumber.h|#171 Very easy.|
|07-29|FactorialTrailingZeroes.h|#172 Very easy.|
|07-30|HappyNumber.h|#202 Easy.|
|07-30|RotateArray.h|#189 A little bit hard to think.|
