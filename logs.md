# Logs
### 2020.07
| Date | File | Description |
| :---- | :---- | :-----------|
|2020-07-12|SearchInsertPos.h|Algo #35. Using binary search.|
|2020-07-12|TwoSum.h|Algo #1. Tried to use hash map. Submitted brute-force solution.|
|2020-07-12|ValidParentheses.h|Algo #20. An easy one. Using stack.|
|2020-07-12|MaximumSubarray.h|Algo #53. Took me some time to solve it. [Review](https://leetcode.com/problems/maximum-subarray/)|
|2020-07-12|BestTimeStock.h|Algo #121. Similar to #53.|
|2020-07-12|BestTimeStock2.h|Algo #122. Another easy one.|
|2020-07-12|Sqrtx.h|Algo #69. Binary search. Faster than 100%.|
|2020-07-13|LongestCommonPrefix.h|#14 The detail matters. Using iterator to see if we meet an end.|
|2020-07-13|ImplementStrStr.h|#28 Brute force. Stupid but simple. |
|2020-07-13|Powxn.h|#50 Recursive method. Write it correctly!|
|2020-07-13|ReverseInteger.h|#7 Don't use compiler features! [Review](https://leetcode.com/problems/reverse-integer/)|
|2020-07-14|DivideTwoIntegers.h|#29 Using bit operations but slow. Maybe I should see if I can improve it someday. [Review](https://leetcode.com/problems/divide-two-integers/)|
|2020-07-14|PlusOne.h|#66 Easy.|
|2020-07-14|ClimbingStairs.h|#70 It's a Fibonacci sequence problem. Don't use recursive method. It's slow!|
|2020-07-15|CountPrime.h|#204 Slow.|
|2020-07-15|ReverseString.h|#344 Very easy.|
|2020-07-16|FizzBuzz.h|#412 Very easy.|
|2020-07-16|SumofTwoIntegers.h|#371 Bit operations. Again, the leetcode complier is strict.|
|2020-07-16|MoveZeroes.h|#283 The use of iterator.|
|2020-07-16|PowerofThree.h|#326 It's like a code cold joke.|
